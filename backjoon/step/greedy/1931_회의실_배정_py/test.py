from solution import solve
from util.test_runner import run_fun_solution

test_cases = [
  # 테스트 케이스 1: 회의가 하나이면 무조건 1개 배정
  (
    "1\n"
    "1 2\n",
    "1\n"
  ),
  # 테스트 케이스 2: BOJ 예제 (11개의 회의)
  (
    "11\n"
    "1 4\n"
    "3 5\n"
    "0 6\n"
    "5 7\n"
    "3 8\n"
    "5 9\n"
    "6 10\n"
    "8 11\n"
    "8 12\n"
    "2 13\n"
    "12 14\n",
    "4\n"
  ),
  # 테스트 케이스 3: 회의들이 서로 겹치지 않아 모두 배정 가능
  (
    "5\n"
    "1 2\n"
    "2 3\n"
    "3 4\n"
    "4 5\n"
    "5 6\n",
    "5\n"
  ),
  # 테스트 케이스 4: 긴 회의 하나와 여러 짧은 회의 – 긴 회의 선택 시 1개,
  #           짧은 회의들을 선택하면 4개가 최대
  (
    "5\n"
    "1 10\n"
    "2 3\n"
    "3 4\n"
    "4 5\n"
    "5 6\n",
    "4\n"
  ),
  # 테스트 케이스 5: 여러 회의가 종료 시간이 동일한 경우
  (
    "6\n"
    "1 4\n"
    "2 4\n"
    "3 4\n"
    "4 5\n"
    "4 5\n"
    "4 5\n",
    "2\n"
  ),
  # 테스트 케이스 6: 입력 순서가 뒤섞인 경우 (정렬 알고리즘 검증)
  (
    "7\n"
    "6 10\n"
    "1 3\n"
    "2 5\n"
    "3 9\n"
    "5 7\n"
    "4 5\n"
    "8 11\n",
    "4\n"
  ),
  # 테스트 케이스 7: 모든 회의가 동일한 시간 구간(동일 회의)
  (
    "5\n"
    "1 10\n"
    "1 10\n"
    "1 10\n"
    "1 10\n"
    "1 10\n",
    "1\n"
  ),
  # 테스트 케이스 8: 0길이 회의(시작 시간과 종료 시간이 같은 경우)
  # 0길이 회의는 종료 시각과 시작 시각이 같으므로 서로 겹치지 않는 것으로 간주되어 모두 배정 가능
  (
    "3\n"
    "1 1\n"
    "1 1\n"
    "1 1\n",
    "3\n"
  ),
  # 테스트 케이스 9: 회의 시간이 다양하게 섞인 경우
  (
    "7\n"
    "2 3\n"
    "1 4\n"
    "3 3\n"
    "5 6\n"
    "4 5\n"
    "6 7\n"
    "5 5\n",
    "6\n"
  ),
  # 테스트 케이스 10: 약간 많은 회의 – 일부는 겹치고 일부는 인접하여 배정 가능한 경우
  (
    "9\n"
    "1 2\n"
    "2 2\n"
    "2 3\n"
    "3 4\n"
    "2 5\n"
    "5 6\n"
    "5 7\n"
    "7 8\n"
    "8 9\n",
    "7\n"
  ),
]


def test():
  for input_data, expected_output in test_cases:
    output = run_fun_solution(input_data, solve)
    assert output == expected_output, f"Input: {input_data!r} Expected: {expected_output!r}, Got: {output!r}"
